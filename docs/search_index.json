[["index.html", "OHI Global Assessment Guide Chapter 1 Overview 1.1 Repositories used to calculate the global assessment", " OHI Global Assessment Guide OHI Team 2021-12-02 Chapter 1 Overview This guide is a resource for calculating the annual Ocean Health Index global assessments. It is intended for use by OHI fellows and anyone interested in the process of how scores are calculated, but only those with access to the internal server (Mazu) are able to actually perform the assessment. By conducting a yearly assessment, the OHI delivers information about a suite of goals important to humans and our use of the oceans. The OHI methods are reproducible and ever-evolving, so updates to this guide are welcomed as improvements and upgrades are incorporated. Content covered in the following chapters includes: How to initialize a new assessment Thorough instructions for data prep, including how to: Access and organize files Structure data prep scripts Gapfill data Check results Update data layers to OHI global and recalculate scores Finalize the assessment, including how to: Review scores Create bibliography Update metadata Create methods and results documents Upload to repository 1.1 Repositories used to calculate the global assessment The OHI uses GitHub repositories (repos) to organize all of the associated data prep scripts, functions/packages, and score calculation materials for each assessment year. There are separate repositories for different parts of the project, which are detailed here. Practicioners of the assessment will clone all repositories to their RStudio workspace, but mainly work in the ohiprep_v20?? repository. OHI github page 1.1.1 ohiprep_v20?? Scripts and intermediate files used to prepare the data layers used by the OHI model are included in this repo. Each year a new version of this repository is created by copying over the previous assessment’s repository contents and deleting the history (more on that later). The suffix of the repo name indicates the year of the assessment (e.g. for 2019, the repo name was ohiprep_v2019) Contents: folder description globalprep Contains R markdown (Rmd) scripts used to prepare all goal, pressure, and resilience data layers. Files are organized by individual data layer, and contain all data, prep scripts, and any other files from previous assessment years in addition to the current assessment year. Reference handy reference materials used throughout the global assessmeent workflow Rmd templates, sourced files, and functions used throughout data preparation 1.1.2 ohi-global This repo contains data layers, supplementary information, models, and scripts used to calculate the global scores. The contents of this repository are updated each time a data layer in ohiprep_v20?? is completed. Contents: folder description eez global models and data eez/layers data layers used in the models (data are copied from ohiprep using paths from metadata_documentation/layers_eez_base.csv) eez/conf models and supplementary data used to calculate scores eez/calculate_scores.R master script used to calculate scores eez/scores.csv score output from calculate_scores.R (includes all score dimensions for each goal and country) metadata_documentation csv files describing data layers yearly_results reporting on results of each year’s OHI assessment documents files used to create OHI methods document 1.1.3 ohicore This is an R package that includes the core functions used in all assessments. See package description for more information. 1.1.4 globalfellows-issues This repository was created in 2018 for the first cohort of Global Fellows, and is used to communicate about the data prep process for each layer, document reference information, share ideas, and keep track of progress on tasks. This repository is used just for writing issues, and is separate from the other repositories where data prep occurs. More information about communicating via issues is found throughout this guide. "],["starting-a-new-year.html", "Chapter 2 Starting a new year 2.1 Review and organize relevant issues 2.2 Prepare the repositories! 2.3 Keeping track of layer progress", " Chapter 2 Starting a new year There are several steps to beginning a year’s assessment. This guide walks through the steps you will want to take. Each of the following steps is described in detail: Review and organize relevant github issues Prepare the repositories ohiprep_v20?? ohi-global Keeping track of layer progress 2.1 Review and organize relevant issues Review the github::issues from the previous year’s assessment and create a list linking to the particular issues that might be useful in the year to come. This can include: references or discussions that may lead to improvements to goal models, pressures or resilience new datasets that are worth exploring potential new improvements to ohicore ideas for reorganizing or cleaning repositories etc. Create a new issue that organizes and links to these issues. This officially marks the start of the OHI assessment! (This is also a good time to close issues that are completed or no longer relevant.) 2.2 Prepare the repositories! In preparation for the new assessment, you will need to prepare the repositories we use for the global assessment. For the ohiprep repository, you will actually copy the previous year’s assessment into a new repository with an updated name and delete the history (more on this below). This helps to keep the size of the repository under control. For the ohi-global repository, you will update a couple files and perform a couple checks to make sure the scores do not change. ohicore will probably not need any changes. However, now is a good time to improve warning messages or add functions to improve analysis and visualization. This is also a good time to think about making organizational changes to the repositories. Sometimes an organizational scheme that worked well in the past doesn’t work as well over time. 2.2.1 ohiprep repository Create a copy of the most recent ohiprep repository and rename with the new assessment year. I use the following steps to do this: If you don’t have the most recent year’s repository, clone it to your local machine. For example, if the last completed assessment was in 2018, you would clone the https://github.com/OHI-Science/ohiprep_v2018. Here is one approach using RStudio: 2. Navigate to https://github.com/OHI-Science and create a new repository. Use the following parameters (but change the year in the repository name to match the current assessment year): 3. Copy the contents of the old ohiprep repository into the newly created repository. Open the ohiprep_v20?? project in RStudio, and navigate to the Shell: Make sure that you are in the old ohiprep working directory. This is indicated by the: C:\\Users\\Melanie\\github\\ohiprep_v2018 If you are not in the correct working directory use the cd command to navigate there. Type in the mirror command: 4. Navigate to the new repository on Github.com, https://github.com/OHI-Science/ohiprep_v20??.git and make sure the folders/files are there. Check that the default branch is “gh-pages” (and not the “master” branch). Clone the new repo to your local system (instructions in step 1) 6. Delete the commit history of the new repository. This gives us a clean slate to work from and keeps the repository from getting quite as big. I follow the general instructions from here. Make sure you are in the working directory of the new repository, and in the shell type the following: Check out to a temporary branch: git checkout --orphan TEMP_BRANCH Add all the files: git add -A Commit the changes: git commit -am \"Initial commit\" Delete the old branch: git branch -D gh-pages Rename the temporary branch to master: git branch -m gh-pages Finally, force update to our repository: git push -f origin gh-pages Navigate to the new repository on Github.com, https://github.com/OHI-Science/ohiprep_v20??.git and check whether there is only one commit. 8. Update README.md and delete unnecessary .Rproj files with the wrong year, commit, push. You are done….go have a cup of tea! 2.2.2 ohi-global The main files that get updated are: eez/conf/scenario_data_years.csv eez/calculate_scores.R 2.2.2.1 scenario_data_years.csv For each data layer, the scenario_data_years.csv associates the year the source data was collected or reported with the OHI assessment year. The data looks like this: In this case, the data layer for ao_access (access to artisanal fishing opportunities data used to calculate the score for the artisanal opportunities goal) goes from 2008 to the most current assessment year (not shown). The first OHI global assessment was in 2012 but the data goes to 2008 because five years of data are typically required to calculate trend. In this case, the 2012 trend was calculated using data from 2008 to 2012. The data year is 2013 for all assessment years because these particular data have never been updated. There is a helper script (metadata_documentation/new_year_prep.R) that updates this file when embarking on a new assessment year. This script adds an additional assessment year to the eez/conf/scenario_data_years.csv. The data year is the same as the previous assessment year. As each data layer is added to update scores, the data year must be manually updated directly within the eez/conf/scenario_data_years.csv. 2.2.2.2 calculate_scores.R The calculate_scores.R script, located in the eez folder, is the main script used to calculate scores. This script creates objects used by ohicore functions, calls ohicore functions that calculate scores, and includes code to check results. This script needs to be updated for a new assessment year. Specfically, links to the ohiprep repository (step 2) and the most recent assessment year (step 3) must be updated. Once this script is updated, it is critical to walk through the entire script to make sure all the steps are working and there are no changes to the previous year’s scores. The ohicore::CheckLayers function will likely generate some warnings. The following warnings are expected and do not indicate a problem: Once the scores are generated, it is important to run the score_check function (step 10). For the scenario_year argument, be sure to provide the year of the most recent completed assessment: Once, this is run, check the html file that is created. This file will be in the eez/score_check folder with the name provided in the function (in the above example file_name = “check_2019_assess”) with the date it was generated. Ideally, this will be a very boring plot comprised of a series of yellow bars, indicating that nothing changed. Sadly, you may actually see something like this: At first glance, the changes to mariculture (and the corresponding food provision goal) and natural products and tourism is worrisome. If there have been no changes to models or data, these should be the same. However, I am somewhat reassured that all the changes are fairly small (&lt;1 point change in score). Regardless, these changes must be explained to convince ourselves that nothing is wrong. In the Git window, I notice that there were some changes to some reference point files. Further exploration reveals that adding an additional year changed the reference points of the mariculture and tourism and recreation goals. This change is fine because the reference points are calculated using all years of data. The small natural product goal changed for the similar reasons. I have now convinced myself that all is well. The final step of this process is to delete the eez/data_check folder. This will be created again at the start of the new assessment! Even though this folder is deleted, the files are preserved in the Git history. We don’t really want this, because these files will not be useful in the future and they are fairly large. This makes the ohi-global more bulky than it needs to be. Eventually, we will want to figure out how to delete these large files from Git history. But I wouldn’t bother until it becomes a problem (i.e., when the ohi-global repository starts taking a crazy long time to clone locally). 2.3 Keeping track of layer progress We use a Google Sheet to help us keep track of where we are in the process of preparing data for the OHI global. The following is part of the 2019 global assessemnt layers checklist: The main part of the checklist is created using code in ohi-global/metadata_documentation/new_year_prep.R. However, the “Notes” are added in secondarily. The “Notes” can be used for many things during this process of conducting an assessment, but starting notes include information that is helpful while preparing the data. These notes are likely to change every year, but here is a place to start: Notes layers not updated, no new data ao_access, cw_trash_trend, eco_status, eco_trend, liv_status, liv_trend, fp_habitat, fp_mora, fp_mora_artisanal, g_mariculture, g_msi_gov, g_tourism, hab_coral_health, hab_coral_trend, hab_mangrove_health, hab_mangrove_trend, hab_saltmarsh_health, hab_saltmarsh_trend, hab_seagrass_health, hab_seagrass_trend, hd_habitat, had_subtidal_hb, le_sector_weight, li_sector_evenness, np_blast, np_cyanide, po_trash, po_water, sp_alien, sp_alien_species not updated, considered static data hab_coral_extent, hab_mangrove_extent, hab_rockyreef_extent, hab_saltmarsh_extent, hab_seagrass_extent, hab_softbottom_extent, rgn_area, rgn_area_inland1km, rgn_area_offshore3nm, rgn_global, rgn_labesl, sp_alien, sp_alien_species, uninhabited not updated, updated in functions.R element_wts_cp_km2_x_protection, element_wts_cs_km2_x_storage, element_wts_hab_pres_abs generated with LSP data fp_mpa_coast, fp_mpa_eez, hd_mpa_coast, hd_mpa_eez generated with SPP data species_diversity_3nm, species_diversity_eez WGI data ss_wgi, wgi_all (pressure and resilience, inverse of one another) SPI data ss_spi, res_spi (pressure and resilience, inverse of one another) before doing this layer, run code in mar_prs_population cw_pathogen_trend layer generated by mariculture script sp_genetic This is also a good time to do a literature search (and review issues during the past year) to determine whether there are new data sources for the layers that aren’t updated because new source data is unavailable. "],["data-prep.html", "Chapter 3 Data Prep 3.1 File organization 3.2 Starting a new data prep project 3.3 A typical data prep script 3.4 prep Rmd: 1. Summary 3.5 prep Rmd: 2. Updates 3.6 prep Rmd: 3. Data sources 3.7 prep Rmd: 4. Set up 3.8 prep Rmd: 5. Data prep 3.9 prep Rmd: 6. Gapfilling 3.10 prep Rmd: 7. Results check 3.11 prep Rmd: 8. Final run 3.12 Notes on parallel processing", " Chapter 3 Data Prep All data layers are prepared in the ohiprep_v20?? repository. Spend some time researching the data prior to launching into the coding in R. I look over the files in the dataprep folder on Github, as well as the Mazu folder that contains the raw data. I research the specific data layers I will be working on and the goals/pressures/resilience dimensions they are used to calculate. I typically start in the methods document. I also research the source data, looking over websites, reports, and published papers. In regard to preparing the data, the best approach is to prepare the layer or layers within a single Rmd script and then update the OHI scores one layer at a time. This approach makes it much easier to identify and track potential errors. This section will discuss: File organization Starting a new data prep project Anatomy of a typical data prep script Notes on parallel processing 3.1 File organization 3.1.1 Saving external data In almost all cases, OHI data comes from other institutions. We save these data to the NCEAS private server (Mazu) because we do not want to be responsible for serving other people’s data. These data are saved to Mazu: git-annex/globalprep/_raw_data in a folder that is labeled with an abbreviated version of the datasource (Figure 1). The data is saved to a folder describing the year the data was downloaded (e.g., d2015, d2016). Figure 1: Location of raw data saved to Mazu. Every raw data folder should have a README.md (keep the caps so it is consistent and easy to see). *Note we are using .md rather than .txt even for READMEs on Mazu. Each README should include the following (template): Detailed source information. For example: full paper citation and link for publication Link to online data source Full email history with data provider If it was downloaded online, provided written and visual instructions so that the reader can mimic your same steps to get the same data. Include screenshots if possible! Version information for data Years included in the datatset Year the data was published Type of data included in the dataset (e.g., catch per species (tons) per country) Any other information that could possibly be useful to anyone 3.1.2 VPN Setup to Access Mazu Here is why you will want to get your VPN accounts set up: You can access files on Mazu while you are offsite You can run intensive memory projects on the Mazu server while you are offsite You will functionally have two computers, so you can set up a long-running processes (on the Mazu server) and then you can work from your personal computer This is especially important when we start working with spatial files. It is impossible to run the spatial analyses on a personal computer due to speed and memory limitations. The VPN allows you to work from the Mazu server when you are not onsite. I almost exclusively work from Mazu. Basically, when I log in, my computer thinks I am working from NCEAS. I can access the Mazu drive. My IP address is through NCEAS and my clock displays the time in Santa Barbara. Here is some information on getting setup: http://www.ets.ucsb.edu/services/campus-vpn/what-vpn and: http://www.ets.ucsb.edu/services/campus-vpn/get-connected Once you have the VPN, here’s how you map Mazu from a Mac: Finder, then do command-K (Or go to the Menu &gt; Go &gt; Connect to Server) Paste: smb://mazu.nceas.ucsb.edu/ohi and then hit Connect! *** 3.1.3 Setting up Rstudio Mazu Server You will definitely want to get set up to run RStudio on Mazu! This is so great for so many reasons. It makes it super easy to work remotely. If you are running long R processes, Mazu is faster and it will not hog your computer’s resources. It is possible to run scripts on Mazu’s multiple cores (which is necessary to run many of our scripts). You need to contact support@nceas.ucsb.edu to get this set up. This is what it looks like on my computer: 3.1.4 Using Cyberduck to Transfer Large Files You should consider looking into Cyberduck (but I wouldn’t bother with this until you find you need it). If you need to move really big files between Mazu and your computer, I find that the VPN typically fails. For this, I use Cyberduck. After you download Cyberduck, open it up and click Open Connection. Type in the server address mazu.nceas.ucsb.edu, your sign-in credentials, select SFTP (SSH File Transfer Protocol) in the drop down at the top (supposed to be safer), AND type in /home/shares/ohi/git-annex under “Path:” Click Connect. Note: You can modify the path if you want to be directed to another location in mazu. Now you can start dragging and dropping! Click Disconnect when you’re done using Cyberduck. *** 3.1.5 globalprep files All of the R scripts and metadata used to prepare the data, as well as the final data layers are saved in the Github ohiprep_v???? repository in the globalprep folder. The only data that will not be saved on Github are files that are too large or incompatible with Github (see below). Primary goal/component folder The folder should be named according to the OHI target (the goal or dimension that the data is used to calculate). For example the folder for the tourism and recreation goal would be called: globalprep/tr (see table below for all folder abbreviations). These recommendations are flexible and should be modified as needed, for example goals can be combined in a single folder (e.g., spp_ico) or, there may be several folders for different components of a single goal (e.g. tr_sustainability and tr_tourists). target suggested folder name Artisanal Fishing Opportunity ao Carbon Storage cs Clean Waters cw Coastal Protection cp Coastal Livelihoods liv Coastal Economies eco Fisheries fis Habitats hab Iconic Species ico Lasting Special Places lsp Mariculture mar Natural Products np Species spp Tourism and Recreation tr Pressure prs_additional_pressure_id Resilience res_additional_resilience_id This folder will contain: a README.md that will link to the appropriate information pages on ohi-science.org The README.md should follow this template. Year-specific folders within the goal/component folder organize output by assessment year (v2015, v2016). Each of the assessment year folders should have: * a README.md (see this template) * a data_prep.R, or .Rmd that is well-documented. Here is the dataprep template. * a series of folders to organize data that include: + raw for ‘raw-ish’ type files that would not be on the server. This is typically for piecemeal raw data that we compile (e.g., U.S. State Department travel warnings), and not data we have downloaded from a single source (which would go on Mazu). In most cases, this folder will not be used. + int for intermediate files (previously we’ve used tmp, working, or other naming conventions so this might not be entirely consistent). + output for the final data layer that is used in the OHI toolbox. The final datasets (the ones stored in the output folder) will be preceeded by the target abbreviation followed by an underscore that provides a brief description of the data, e.g., tr_sustainability.csv). 3.1.6 Intermediate files that are too large for Github These files will be saved on Mazu, the internal server’s, globalprep folder. Our goal is to have everything (except for data obtained from other sources) stored on GitHub, but some files are too large or inappropriate for GitHub and must be stored on Mazu. Each of these files should be stored in a way that mirrors that on Github. If there is a need to make a duplicate folder on git-annex, it should have the same name as the folder used in GitHub. Store any intermediate or final output files that are too large for github in these folders. Keep the same subfolder structure. If you are working in spp_ico and have temporary rasters to store on Mazu, save them in a folder named int. Raw data should not be stored here. This should be stored in Mazu’s _raw_data folder 3.2 Starting a new data prep project 3.2.1 Prepare the dataprep folder In ohiprep_v20??/globalprep navigate to the folder that contains the files you will need to prepare the data. Select the most recent assessment year of data and copy/paste to create a new folder in the same location, changing the name to reflect the current assessment year. For example, if we are preparing data layers for the 2019 assessment for the artisanal opportunities goal, ao, we would copy the v2018 folder and name it v2019. Next, delete all unnecessary files, particularly the files in the raw, intermediate, and output folders! New versions of these data will be created in the updated data_prep script, and you want to be sure that this is indeed what happens. If there are data already in the folder it can be easy to overlook a mistake, such as not using the correct file path to save the data, etc.. Typically, you will not delete the dataprep script/s and README. You will also want to preserve the folder structure. If in doubt, I delete the files and then copy them over as needed. For some goals, such as fisheries, there are lots and lots of files and it is very confusing. In these cases, I just copy the files as I need them. Once you have created and cleaned the new folder commit and push the updates! 3.2.2 Start an issue On Github create an issue for this dataprep project. Here you will document progress, report problems or concerns, pose questions, describe changes to code, and report on final results. For example, if working on the artisanal opportunities dataprep, name the issue “Artisanal opportunities.” Once the relevant data layers are created and incorporated into the OHI scores this issue will be closed. 3.2.3 Update the files Carefully walk through the data prep scripts and update as necessary. You will also need to update READMEs. As you check and update the scripts, don’t assume everything is correct. There could be changes to the source data that introduce errors (this often happens). We could have made a mistake somewhere. And, even if there aren’t any mistakes, there is usually room for improvement. Checking the dataprep scripts involves: Going through each line of code to understand what is happening. Each step of dplyr chains should be evaluated, rather than running the entire chain and assuming it is correct. Using functions such as summary, dim, length functions and figures to explore the data at different stages of preparation. Check the dimensions of the dataframe after each join or spread/collapse to ensure the length of the updated data makes sense. Check that the frequency of NA values seems reasonable, especially after joins and spread/collapse functions. And, if you gapfill missing values, make sure that you end up estimating all NA values. Note: for some layers, uninhabited/low-population regions will be manually assigned NA values. 3.3 A typical data prep script All data prep is performed in R or, preferrably, R Markdown (Rmd) documents. Rmd is an ideal format because it seemlessly integrates code and documentation, can display figures, and the output provides a clean methods document. We have several shared practices for preparing data: Ideally Rmd/R files are used to download and save source datafiles, but this isn’t possible in most cases due to the format of the data. We put a large premium on documenting the steps used to prepare data! In many cases, the data preparation for a goal is performed in a single file. But, for more complex goals it is better to break the data preparation into multiple Rmd documents. If multiple Rmd documents are used, a README must describe what each Rmd document does, the input/outputs, and the order of processing. If a process is run multiple times, the code should be converted to a function and placed in folder labeled R or worklflow. The here package, and here() function should be used control relative file paths. We use the tidyverse for tidying data A typical data prep script (or series of scripts) will include the following sections, which are described in more detail below: Summary: general description of the data prepared by the script Updates: updates to source data and/or methods from previous year Data sources: description of source data Set up: code chunk that loads relevant R packages and functions Data prep: code chunks for preparing the data, this is typically the bulk of the Rmd file Gapfilling: code chunks for estimating and documenting missing data Results check: code used to check results Final run: a final run of all the code after restarting R A generic data prep Rmd file is located on Github: https://raw.githubusercontent.com/OHI-Science/ohiprep/master/src/templates/generic_data_prep.Rmd 3.4 prep Rmd: 1. Summary This section describes the purpose of the script and the data layers that are generated. For example, the 2019 AO summary looks like this: “This script generates the”need” layer for the artisanal opportunities goal. The “access” layer, which is not updated due to a lack of a data source, is located here: globalprep/res_mora_ao/v2013/data/r_mora_s4_2013a.csv.” 3.5 prep Rmd: 2. Updates This section describes all the updates to source data and/or methods since the previous year’s assessment. For example, the 2019 AO updates look like this: “Uninhabited and low population regions now given an NA value (vs. a gapfilled value).” “Added an additional year of GDP data from the World Bank” 3.6 prep Rmd: 3. Data sources This section describes all data sources and may include: Reference: [citation for source data; website, literature, contact information. Version of data (if relevant).] Downloaded: [date downloaded or received] Description: [e.g., surface aragonite state] Native data resolution: [e.g., 1 degree, 30 m, country, etc.] Time range: [e.g., 1880-1899, monthly data provided for each year] Format: [e.g., NetCDF, Excel file] For example, the 2018 AO data sources section looks like this: Downloaded: 7/23/2018 Description: GDP adjusted per capita by PPP (ppppcgdp) http://data.worldbank.org/indicator/NY.GDP.PCAP.PP.KD Reported at country scale. GDP per capita based on purchasing power parity (PPP). PPP GDP is gross domestic product converted to international dollars using purchasing power parity rates. An international dollar has the same purchasing power over GDP as the U.S. dollar has in the United States. GDP at purchaser’s prices is the sum of gross value added by all resident producers in the economy plus any product taxes and minus any subsidies not included in the value of the products. It is calculated without making deductions for depreciation of fabricated assets or for depletion and degradation of natural resources. Data are in constant international dollars based on the 2011 ICP round. Data is available directly to R through the WDI package. Time range: 1990-2017 3.7 prep Rmd: 4. Set up This code chunk is used to load packages, source functions, and set variables used throughout the analyses. Here, you can also initialize programatic creation of raw, intermediate and output file folders within the specific layer directory: # check if &#39;raw&#39;, &#39;intermediate&#39;, and &#39;final&#39; folders exist in the current assessment folder, if not, then create the folder in the working directory if (!file.exists(here(&quot;globalprep/layer_name/v20??/raw&quot;))){ dir.create(here(&quot;globalprep/layer_name/v20??/raw&quot;)) } if (!file.exists(here(&quot;globalprep/layer_name/v20??/intermediate&quot;))){ dir.create(here(&quot;globalprep/layer_name/v20??/intermediate&quot;)) } if (!file.exists(here(&quot;globalprep/layer_name/v20??/output&quot;))){ dir.create(here(&quot;globalprep/layer_name/v20??/output&quot;)) } 3.7.1 Packages The packages we load depend on the analyses, but we always use: dplyr and tidyr: data wrangling tools a cheatsheet 3.7.1.1 Packages commonly include, but are not limited to: OHIcore package which contains all the proprietary OHI functions library(ohicore) Check to see if it is installed and install it if not: if (!(\"ohicore\" %in% installed.packages())){devtools::install_github(\"ohi-science/ohicore\")} General data analysis and wrangling packages: library(here) - controls file paths, learn more here library(tidyverse) - includes ggplot2, readr, stringr, tidyr, and dplyr library(plotly) - create interactive ggplots library(zoo) - usually used for time series data Packages used for spatial analysis: library(raster) - reading, writing, manipulating, analyzing and modeling of gridded spatial data library(fasterize) - a better way to convert a shapefile to a raster file library(sf) - a new version of sp, providing a standardized way to encode spatial vector data library(sp) - classes and methods for spatial data library(rgdal) - tools for dealing with coordinate reference systems Parallel processing libraries (usually used for data prep involving large spatial files): library(parallel) library(foreach) library(doParallel) 3.7.2 common.R Nearly all scripts will source a common.R file. This file creates several objects that make it easier to conduct an OHI assessment. This includes: object description dir_M file path to Mazu mollCRS crs code for the mollweide coordinate refernce system we use in the global assessment regions_shape() A function to load a simple feature object called “regions” with polygons for land/eez/highseas/antarctica regions. The “regions” object uses the Mollweide coordinate reference system. ohi_rasters() function to load two rasters: global eez regions and ocean region rgn_data() function to load 2 dataframes describing global regions rgn_syns() function to load dataframe of region synonyms (used to convert country names to OHI regions) low_pop() function to load dataframe of regions with low and no human population UNgeorgn() function to load dataframe of UN sociopolitical regions, typically used to gapfill missing data To load the data in a data function: source(&#39;http://ohi-science.org/ohiprep_v2019/workflow/R/common.R&#39;) ## This file makes it easier to process data for the OHI global assessment ## by creating the following objects: ## ## * dir_M = identifies correct file path to Mazu (internal server) based on your operating system ## * mollCRS = the crs code for the mollweide coordinate reference system we use in the global assessment ## * regions_shape() = function to load global shapefile for land/eez/high seas/antarctica regions ## * ohi_rasters() = function to load two rasters: global eez regions and ocean region ## * region_data() = function to load 2 dataframes describing global regions ## * rgn_syns() = function to load dataframe of region synonyms (used to convert country names to OHI regions) ## * low_pop() = function to load dataframe of regions with low and no human population ## * UNgeorgn = function to load dataframe of UN geopolitical designations used to gapfill missing data ## Warning in showSRID(uprojargs, format = &quot;PROJ&quot;, multiline = &quot;NO&quot;, prefer_proj ## = prefer_proj): Discarded datum Unknown based on WGS84 ellipsoid in Proj4 ## definition # call the function to load the data, the message describes the available data: region_data() ## loads 2 dataframes: rgns_all and rgns_eez ## rgns_all = includes eez/high seas/antarctica regions, IDs correspond with region shapefile and raster ## rgns_eez = includes only eez regions head(rgns_all) ## rgn_type type_w_ant rgn_id rgn_ant_id rgn_name ## 1 eez eez 1 1 Cocos Islands ## 2 eez eez 10 10 Nauru ## 3 eez eez 100 100 Republique du Congo ## 4 eez eez 101 101 Namibia ## 5 eez eez 102 102 South Africa ## 6 eez eez 103 103 Sao Tome and Principe head(rgns_eez) ## rgn_id rgn_name eez_iso3 territory admin_rgn_id admin_country_name ## 1 1 Cocos Islands CCK yes 16 Australia ## 2 2 Christmas Island CXR yes 16 Australia ## 3 3 Norfolk Island NFK yes 16 Australia ## 4 4 Macquarie Island AUS yes 16 Australia ## 5 5 New Caledonia NCL yes 179 France ## 6 6 Vanuatu VUT no 6 Vanuatu ## Notes ## 1 ## 2 ## 3 ## 4 ## 5 ## 6 3.7.2.1 metadata for common.R dir_M and mollCRS The following are the dir_M and mollCRS objects: ## dir_M describes the path to our internal server based on your computer&#39;s operating system ## NOTE: The following may be different on your operating system dir_M ## [1] &quot;/home/shares/ohi&quot; ## mollCRS is the code for the Mollweide coordinate reference system mollCRS ## CRS arguments: ## +proj=moll +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs regions_shape The regions_shape function returns a simple feature object called “regions.” Regions is the master global shapefile that includes polygons for land, eez, high seas, and antarctica regions in the Mollweide coordinate reference system. Sometimes it is necessary to convert from a simple feature object to a shapefile object because some functions still do not work with simple feature objects, or, if the spatial file is modified, a saved shapefile may be desired. This is accomplished like this: regions_shape &lt;- as(regions, \"Spatial\") The regions file with eez (dark blue), fao or high seas (light blue), and antarctica or CCAMLR (green) regions. The regions object is a simple feature multipolygon spatial object in the Mollweide coordinate reference system. There are 7 fields described in the table field data type description examples type_w_ant factor identifies all polygons as eez, fao (high seas), ccamlr (antarctica), or land eez (n=220), fao (15), eez-ccamlr (19), land (220), land-ccamlr (9), eez-disputed (1), land-disputed (1), eez-inland (3), land-noeez (38) rgn_type factor similar to type_w_ant, but does not specify eez/ccamlr and land/land-ccamlr regions eez (n=239), fao (15), land (229), eez-disputed (1), land-disputed (1), eez-inland (3), land-noeez (38) rgn_ant_id numeric region ids 1-250 country land and eez (these are the official global regions; some numbers are skipped); 255 disputed land and eez; 260-277 fao high seas; 301-337 (country land, no eez); 248100-288300 CCAMLR regions rgn_id numeric region ids; similar to rgn_ant_id, but Antartica/CCAMLR regions lumped as region 213 1-250 country land and eez (these are the official global regions; some numbers are skipped); 255 disputed land and eez; 260-277 fao high seas; 301-337 (country land, no eez) rgn_name character country/territory name e.g., Afghanistan, Belize, Prince Edward Islands rgn_key factor 3 letter identification code e.g., AFG, BEL area_km2 numeric area of region, km2 range of 1-30604795 ohi_rasters The ohi_rasters function returns two rasters, “zones” and “ocean,” both with ~1 km resolution and the mollweide coordinate reference system. The “zones” raster cell values are the OHI region ID. The raster cell values can be linked to the region names using the region_data() function, and the rgn_ant_id variable from rgns_all.csv. This raster is typically used to extract pressure data for the eez regions. The “ocean” raster identifies ocean cells with a value of 1, and other cells are NA [NOTE: There is something weird about this raster in that it lists the values as 0, 255 (min, max), when in fact there are only 1 and NA values! If you need to convince yourself of this, you can use the freq(ocean) function to identify all cell values.]. This raster file is typically used to mask the ocean regions for pressure data. region_data() The region_data function returns two dataframes, “rgns_all” and “rgns_eez.” The “rgns_all” dataframe includes data for the eez, fao, and ccamlr ocean regions. The IDs in rgn_ant_id correspond to the IDs in the zones raster. Once raster data are extracted for each region, the output is often aligned with the data in this dataframe. Metadata for rgns_all dataframe field data type description examples rgn_type factor similar to type_w_ant, but does not specify eez/ccamlr and types eez (n=239), fao (15) type_w_ant factor identifies all ocean polygons as eez, fao (high seas), ccamlr (antarctica) eez (n=220), fao (15), eez-ccamlr (19) rgn_id numeric region ids; similar to rgn_ant_id, but Antartica/CCAMLR regions lumped as region 213 1-250 country eez (these are the official global regions; some numbers are skipped); 255 disputed eez; 260-277 fao high seas rgn_ant_id numeric region ids 1-250 country eez (these are the official global regions; some numbers are skipped); 255 disputed eez; 260-277 fao high seas; 248100-288300 CCAMLR regions rgn_name character country/territory name e.g., Afghanistan, Belize, Prince Edward Islands The “rgns_eez” dataframe includes data for the 220 OHI regions plus Antarctica (rgn_id 213). This file is used to make sure that all regions are included in dataprep files. It also includes data to indicate whether regions are territories. This can also be used for gapfilling (in some cases, it makes sense to assign territories the same value as their administrative country). Metadata for rgns_eez dataframe field data type description examples rgn_id numeric official global regions (except Antarctica, 213) 1-250 rgn_name character country/territory name e.g., Afghanistan, Belize, Prince Edward Islands eez_iso3 factor 3 letter identification code e.g., AFG, BEL territory boolean identifies whether the region is a territory yes/no admin_rgn_id numeric administrative country rgn_id if a territory, otherwise the rgn_id 1-250 admin_country_name character administrative country name if a territory, otherwise the country name e.g., Afghanistan, Belize, Canada region_syns() Observed synonyms for each region, such that each region may have multiple synonyms. These data are used to convert outside data to the OHI region name and ID. This list is updated nearly everytime we run an assessment! Metadata for region_syns dataframe field data type description examples rgn_id numeric region ids 1-250 rgn_name character country/territory name e.g., Federated State of Micronesia; Micronesia, FS; Micronesia (Federated States of) rgn_key factor 2-letter code for countries e.g., FM eez_iso3 factor 3-letter code for countries e.g., FSM rgn_typ factor status of region disputed, landlocked, largescale (global, world); ohi_region low_pop() Includes data for 21 regions with 0 and low populations. These data are used to identify regions that should have NA values because the goal does not apply to regions with no/low populations (e.g., livelihoods and economies). Metadata for low_pop dataframe field data type description examples rgn_id numeric region ids 1-250 rgn_nam character country/territory name e.g., Macquarie Island, Wake Island Southern_Island boolean indicates if region is a southern island 1/0 Inhabited boolean indicates if region is uninhabited boolean, 1/0 est_population numeric number of established people in region 0-3000 UNgeorgn() Each global regions UN georegion based on social and geopolitical considerations. Metadata for UNgeorgn dataframe field data type description examples rgn_id numeric region ids 1-250 r0_label factor most inclusive category World r1_label factor 7 classes Africa (N=46), Americas (3), Asia (39), Europe (43), Latin America and the Caribbean (48), Oceana (34) Southern Islands (7) r2_label factor 22 classes e.g., New Zealand, Melanesia rgn_label character global region name e.g., Cocos Islands, Christmas Island Inhabited boolean indicates if region is uninhabited boolean, 1/0 est_population numeric number of established people in region 0-3000 3.8 prep Rmd: 5. Data prep We follow several coding practices when preparing our data: Code chunks are broken into manageable pieces and are proceeded by a description of what is being accomplished The code within a chunk is documented to make it easier to follow and to help prevent errors. For example, expected values and results are described to help prevent potential errors (e.g., check to see all values between 0-1, length should be 0, etc.). Run-on dplyr chains are avoided because they are impossible to follow and prone to error! Data is checked throughout the dataprep process (checking dimensions of data after joins, special attention to missing data, etc.) Intermediate data files are saved if they computationally take a long time to create or have information that could be useful in other aspects of the analysis. The here package is used to standardize file paths. The final output should be a dataframe that includes: rgn_id All 220 regions should be included in the final file! year This should include all years of data necessary to calculate scores for all scenario years, including trend. For some data layers the data has never been updated, in these cases, there is still a year column but it may only contain a single year. value This column will contain the calculated value for the data, and the column name will vary across datasets. In general, naming conventions should be consistently used every year, but feel free to modify the column name if you feel it could be improved. Just be sure to make the corresponding change to the “name_data_fld” in this file: https://github.com/OHI-Science/ohi-global/blob/draft/eez_layers_meta_data/layers_eez_base.csv. This file should be saved as a .csv file in an “output” folder. In general, the name of the file should be the same as the previous year. However, if you feel the file name can be improved, you will need to update the fn variable in this data file: https://github.com/OHI-Science/ohi-global/blob/draft/eez_layers_meta_data/layers_eez_base.csv 3.8.1 OHI data idiosyncracies: Low population/uninhabited regions and grouped regions Recently we have standardized how we identify low population regions, using the low_pop() function in the common.R file. These regions are assigned NAs for some goals (e.g. GDP values used in AO) and perfect scores for others (e.g. sanitation access). Use the following code to establish a vector of low pop regions that can be compared against the final dataset. # After sourcing common.R and gapfilling data: low_pop() # Filter out regions that have populations &gt; 3000 and keep NA values low_pop &lt;- low_pop %&gt;% filter(est_population &lt; 3000 | is.na(est_population)) # Make a vector of low population region IDs: low_pop_vector &lt;- c(low_pop$rgn_id) # Assign NA values in score column for low popuation areas: gapfilled_dataset$score[gapfilled_dataset$rgn_id %in% low_pop_vector] &lt;- NA Several of the datasets we use also report OHI regions as a group, and we want to report them all at the same scale/resolution used in OHI. For instance, Bonaire, Sint Eustatius and Saba are often reported together as “Caribbean Netherlands” or combined as “Bonaire, Sint Eustatius and Saba.” Use the following code to apply the data to all three regions: # Assuming &quot;tidy_dataset&quot; has been wrangled, cleaned, and has column &quot;country&quot; CN &lt;- filter(tidy_dataset, country==&quot;Caribbean Netherlands&quot;) %&gt;% rename(country_old = country) # country could also be rgn_name CN_subregions &lt;- data.frame(country_old = &quot;Caribbean Netherlands&quot;, country = c(&quot;Bonaire&quot;, &quot;Sint Eustatius&quot;, &quot;Saba&quot;)) %&gt;% left_join(CN) %&gt;% select(-country_old) # Remove lines of data for Caribbean Netherlands and replace with individual region-level data for the three subregions: tidy_dataset &lt;- tidy_dataset %&gt;% filter(country != &quot;Caribbean Netherlands&quot;) %&gt;% rbind(CN_subregions) 3.9 prep Rmd: 6. Gapfilling We make every effort to gapfill missing data. The only legitimate reason for a region to have an NA value is if the goal is not relevant to the region. For example, the livelihoods and economies goal is not relevant for an uninhabited island. We have a paper describing why and how we estimate missing data: https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0160377. But the following is the short version. The first step to gapfilling missing data is to identify datasets that are predictive of the variable you are attempting to estimate and is also more complete. Here are some of the general approaches we use to estimate missing global data: Some missing data can be estimated from the original source. For example, if there are some missing years within a dataset, we can often estimate these values using a linear model of available data. For spatial raster data, we often estimate missing values using nearby raster cells. Secondary datasets can also be used to estimate missing values. For example, we gapfill some missing Social Progress Index values using World Governance Index data as a predictor. And, in many cases we use UN geopolitical data that classifies countries based on geopolitical and social variables to predict missing data. And, we often use multiple approaches to estimate missing values within a dataset. Our goal is to estimate missing data using the simplest model that best predicts the data. Given this, it is necessary to determine whether datasets and model terms actually predict missing data and to compare the performance of multiple models. Ideally cross-validation methods are used to evaluate how well the models predict missing data, otherwise models will appear to perform much better than they actually do. There is no point in having a model with many predictive variables and complex non-linear fits if it performs no better than using a simple mean of the existing data! 3.9.1 Training linear models for gapfilling Basic gist: Use alternative datasets to predict data points for a dataset you have limited data points for. In this instance, we had FMI data points for 40 regions included in the OHI, and needed to gapfill the remaining 180 regions. We checked for correlation between the FMI data and several other datasets, including AO need (rescaled GDP per capita per person purchasing power), GDP per capita, social progress index (SPI), world governance indicator (WGI), and UN georegions. A detailed example can be found here Steps: Collect data that you’ll use to predict values, and merge with existing data (only use the values that correspond to data you already have to create this df) Look at correlation between alternative data sets cor.test() and pairs.panels() Create initial model: mod1 &lt;- lm(dep_variable ~ ind_variable, data=df_name) Look at summary(mod1) to check for R-squared and p-value Create an array of predicted values: df_predicted &lt;- df_name %&gt;% dplyr::group_by(rgn_id) %&gt;% dplyr::do({ pred &lt;- predict(mod1, newdata =.[c(&#39;ind_variable&#39;)]) # creates a new column for predicted values data.frame(., fmi_pred) # do loop applies the model fitting and prediction to each country group }) %&gt;% dplyr::ungroup() Plot predicted vs actual values: ggplotly(ggplot(df_predicted, aes(x = dep_variable, y = pred, labels = rgn_id)) + geom_point() + geom_abline(slope = 1, intercept = 0, color = &quot;red&quot;)) Note: “rgn_id” is just an example of a column in the dataset with a unique value for each observation. lm() can also include multiple independent variables (must be merged into one data frame with one row for each observation): mod2 &lt;- lm(dep_variable ~ ind_variable + ind_variable2, data=df_name) Compare models for fit and degrees of freedom: AIC(mod1, mod2) Use best-fit model to gapfill areas without data using do loop as shown in step 4. If using UN georegions to gapfill, you’ll want to use the most specific/granular label possible. Use separate models for regional and continental levels (r2_label vs r1_label as described in metadata above), and write code to tell R to grab the data from the most granular data available. Example from FMI model comparison .Rmd: fmi_gf_all &lt;- fmi_gf1 %&gt;% left_join(fmi_gf2, by=c(&quot;rgn_id&quot;, &quot;r1_label&quot;, &quot;r2_label&quot;, &quot;rgn_label&quot;, &quot;year&quot;, &quot;spi&quot;, &quot;fmi&quot;)) %&gt;% mutate(gapfilled = ifelse(is.na(fmi) &amp; !is.na(fmi_pred_r2), &quot;1&quot;, 0)) %&gt;% mutate(method = ifelse(is.na(fmi) &amp; !is.na(fmi_pred_r2), &quot;SPI + UN_geopolitical region r2&quot;, NA)) %&gt;% mutate(fmi = ifelse(is.na(fmi), fmi_pred_r2, fmi)) %&gt;% mutate(gapfilled = ifelse(is.na(fmi) &amp; !is.na(fmi_pred_r1), &quot;1&quot;, gapfilled)) %&gt;% mutate(method = ifelse(is.na(fmi) &amp; !is.na(fmi_pred_r1), &quot;SPI + UN_geopolitical region r1&quot;, method)) %&gt;% mutate(fmi = ifelse(is.na(fmi), fmi_pred_r1, fmi)) 3.9.2 Saving gapfilling report files Gapfilling steps are often mixed with the dataprep code. Once the gapfilling is done, we will save a dataset describing which data were gapfilled and the method. Every dataset should have a corresponding gapfilling dataset…even if there was no gapfilling. The gapfilling record is saved with the same name as the corresponding output data, but with a “_gf” extension. The gapfilling dataset should mirror the corresponding dataset in regard to the number of rows and identifying columns (e.g., rgn_id, commodity, year, etc.). The gapfilling datset should include three additional columns that indicate the following: gapfilled: a zero or one value (or, NA if the value in the original data is NA) indicating whether the data was gapfilled or not. method: a short descriptor of the method that was used (this should be described more fully somewhere in the documentation). error: a numeric value describing the error around the estimate. This should be left blank if this was not determined (most of the time this will not be estimated). 3.10 prep Rmd: 7. Results check It is critical to check the final output data! Here are some of the ways we check data: Is each region included in the final data? Does the number of values for each region/year make sense (in most cases there should only be one value for each region/year) Does the ranking of the values make sense? Do the high and low performing regions seem reasonable? Do the number of NA values seem reasonable (ideally there will be none, unless the goal does not apply to that region) Does the range/distribution of values seem reasonable, for example, some outputs should range from 0-1. The functions I use most commonly to check data are: hist(), summary(), dim(), table() Because we calculate the global index every year, the most powerful way of checking our data is to compare the current data with last year’s data. In most cases, source data will remain the same from year to year (although some agencies will update previous data). Consequently, any changes will often reflect changes to the model and/or mistakes. For this comparison we typically compare the most recent shared year of data between the two assessments. The following code walks through this process using data calculated for the lasting special places goal. In this case, we will pretend we have just completed preparing the data for the 2018 assessment and we want to compare the results to the 2017 assessment. Here we focus on the data for the 3nm offshore region. library(dplyr) library(here) library(ggplot2) library(plotly) # want the region data from here: source(&#39;http://ohi-science.org/ohiprep_v2019/workflow/R/common.R&#39;) new &lt;- read.csv(here(&quot;globalprep/lsp/v2018/output/lsp_prot_area_offshore3nm.csv&quot;)) summary(new) old &lt;- read.csv(here(&quot;globalprep/lsp/v2017/output/lsp_prot_area_offshore3nm.csv&quot;)) summary(old) The most recent shared year between the two datasets is 2017, so this is the year that will be compared. The old and new values are plotted as a scatterplot, with a point for each region. We create an interactive plot and add a one-to-one line to make it easier to determine which regions have changed. Any changes in values will reflect either changes to the source data or changes to the data prep script. It is important to explore the reasons for these changes because it could reflect errors! # get region names region_data() head(rgns_eez) compare &lt;- new %&gt;% rename(a_prot_3nm_new = a_prot_3nm) %&gt;% left_join(old, by=c(&quot;rgn_id&quot;, &quot;year&quot;)) %&gt;% filter(year == 2017) %&gt;% left_join(rgns_eez, by=&quot;rgn_id&quot;) %&gt;% select(rgn_id, rgn_name, year, a_prot_3nm, a_prot_3nm_new) %&gt;% mutate(region=paste(rgn_id, rgn_name, sep = &quot;-&quot;)) summary(compare) compare_plot &lt;- ggplot(compare, aes(x=a_prot_3nm, y=a_prot_3nm_new, label=region)) + geom_point() + geom_abline(slope=1, intercept=0, color=&quot;red&quot;) ggplotly(compare_plot) In this case, the values for most regions remain the same from the 2017 to 2018 assessment, however, there are some changes. The biggest change was for Antarctica, which we can ignore because we do not calculate scores for Antarctica for the global assessment. However, there is also a fairly large change in the Greece data, and some smaller changes for some other regions. By carefully exploring the source data we found that these differences reflect updates to the source data. For example, a marine reserve may have been established in 2017, but weren’t yet incorporated into the World Database on Protected Areas. 3.11 prep Rmd: 8. Final run The final step is to commit and push all files. Then, close R and do NOT save the workspace image. The purpose of closing everything is to clear the memory of all data objects to make sure that the code still runs. This may be a problem if we change object names but fail to make necessary corresponding throughout the code. I typically close everything by opening another repository. Restart R and return to the ohiprep repo and rerun everything (except any really long processes). Check the following: Does all the code still run? Do you get the same results (check to see if output csv files are loaded to the Git window, this indicates that the data probably changed)? Review warnings Identify parts of the code you are unsure of, and have someone review 3.12 Notes on parallel processing In OHI, we often use parallel processing packages to process data-intensive spatial layers. Parallel processing allows multiple computations to take place at the same time. For more information, check out this introductory resource from NCEAS. Note: below is essentially copy and pasted from this reference issue and might need more context to be helpful Vignette on getting started with doParallel and foreach packages refers to two ways to use parallel processing in the doParallel package. Method 1: registerDoParallel(4) OR Method 2: cl &lt;- makeCluster(4) registerDoParallel(cl) foreach(i in 1:10) %dopar%{} stopCluster(cl) 3.12.1 stopCluster &amp; makeCluster Stopping your cluster: If you are using snow-like functionality, you will want to stop your cluster when you are done using it. The doParallel package’s .onUnload function will do this automatically if the cluster was created automatically by registerDoParallel, but if you created the cluster manually you should stop it using the stopCluster function: stopCluster(cl) Stack overflow discussion on whether cores stop being registered after foreach finishes Tip: Limit to 5 or fewer cores for any data prep 3.12.2 Using htop to check on processes running Sometimes a process will be running that slows down the whole system, and htop can help identify and stop the source of this issue. Useful resource here When you are logged into the Mazu RStudio server window, open the terminal shell. type htop and hit enter When you press enter, a matrix will appear showing how many cores are being used, and the processes running underneath Kill processes by scrolling with arrow keys or by clicking on them. Click ‘kill’ or hit k on the keyboard ‘Send signal’ bar will open with 15 SIGTERM highlighted - hit enter, or esc to cancel Note: some users have problems with RStudio crashing when trying to kill processes in the terminal window. Using the terminal on your computer should work with no problem. To do this, open the terminal and login using ssh username@mazu.nceas.ucsb.edu and hit enter. Enter your password (letters will not appear) and hit enter to login, then follow the steps above. "],["updating-scores.html", "Chapter 4 Updating scores", " Chapter 4 Updating scores After we have completed the data prep for a single layer, we update the information to the OHI-global repository to calculate global EEZ scores. Follow these steps to upload the data to OHI-global: Make sure that all ohiprep_v20?? files are saved, committed and pushed to Github. Ensure that OHI-global is cloned to your workspace and switch to that project in RStudio. Pull most recent draft of ohi-global from Github. Open metadata_documentation/layers_eez_base.csv and update the directory and filenames. (Other data may also need to be updated) You will need to export the csv file to your computer, edit it in Excel, then upload back into RStudio. Update eez/conf/scenario_data_years.csv (this can be done in RStudio, as you will just be updating the data years in this file.) Walk through eez/calculate_scores.R line by line. As you go through, check output in Git window: are the correct files being updated? Do changes in score.csv seem reasonable? In the score_check() function at Step 10 in calculate_scores.R, check the scenario_year and change file_name to an alias representing the layer name (e.g. “np” for natural products) Explore data in eez/score_check/layer_alias_score_check.html to see how this year’s data compare to last year’s. If everything looks good (you might want to write down any outliers and take a screenshot of the commit comparison scatter to explore later), save, commit and push all of the changes to Github. Post screenshot to Github issues for review. Update the layers_checklist (Google spreadsheet) with the status of each layers and close Github issues as appropriate. Downloadable checklist: "],["finalizing-the-global-assessment.html", "Chapter 5 Finalizing the global assessment 5.1 Create results folder 5.2 Final score review 5.3 Citation management 5.4 Methods document 5.5 Results document 5.6 Update ESRI Living Atlas of the World OHI map 5.7 Updates document 5.8 Upload to a repository", " Chapter 5 Finalizing the global assessment There are several steps after getting the scores to finalizing an assessment. This guide walks your through these steps. Each of the following steps is described in detail below: Create results folder Final score review Methods document Results document Updates document Update the website Finalize and create a “release” for repositories Upload to repository 5.1 Create results folder We summarize the results from each year’s assessment in the yearly_results/global20?? folder, located in the ohi-global repository. After the OHI scores have been updated with the new data layers a global20?? folder should be created in the ohi-global/yearly_results folder, and populated with: an empty “data_check” and “Results” folder a copy of the README”, “Results_first_look.Rmd,” “Results/Supplement_Results.Rmd,” and “Results/functions” from the previous year you may find other files from previous years to be useful as well, but only copy them as needed (many of the files were created to meet needs specific to a particular assessment year) The Results_first_look.Rmd creates an internal html document that provides our first look at the scores. This is mostly used internally to explore and check results. This script also does the following: copies the scores.csv from the eez folder to this (yearly_results/global20??) folder and appends the current date to the filename. This allows us to version control our data so we can keep better track of it. This is especially handy during the final stages of an assessment when there are lots of versions of the data flying around email and such! creates a user friendly version of the data called OHI_final_formattted_scores_date.csv. This is typically the version of data we provide to people. creates most of the data in the Results/data folder and figures in the Results/figures folder. It will be necessary to carefully walk through the previous year’s version of the Results_first_look.Rmd file and make relevant updates as needed, such as: on ~ line 88 change: update_data = TRUE on ~ line 84 change the dateFile to the current date, e.g., dateFile = '2018-10-03' correct links: Data read through to correct references to scores/regions If there are any changes to the scores the Results_first_look.Rmd must be updated and rerun. 5.2 Final score review Once all the data layers have been updated we conduct a final review of the scores, which involves these steps: Update and disperse the Results_first_look.html to team members to review. Meeting with team members to discuss scores, document questions/concerns in a new Github issue. To address these concerns, review the data/code and, if necessary, update the scores with corrections to the data or code. These checks are performed via R/Rmd scripts in the yearly_results/global20??/data_check folder. The results from each check is also documented in the Github issue. Update and rerun the Results_first_look.Rmd as needed If necessary, we have a second meeting to discuss the updated scores (usually this isn’t necessary). 5.3 Citation management Here is a great reference from the fine folks at RStudio. 5.3.1 Getting Zotero and RStudio to work well together 5.3.1.1 The process: short version Create a Zotero library or collection, export it as .bib (or other formats - seems flexible) Call the bibliography file and a citation style (optional) in your R Markdown YAML header Create your citations in the body of the R Markdown text using (name_shorttitle_2016?) format Hit “knit” - done! 5.3.1.2 The process: long version Exporting a bibliography file from Zotero Once you’ve created your library (or collection/folder/whatever) in Zotero, you can export it in BibLaTex format (the whole library from the File menu, or the collection by right-clicking and choosing “Export Collection,” then selecting “BibLaTex” as the format: This creates a .bib file, which contains a list of references each formatted like this (I deleted many of the fields just for the sake of space): @article{ready_predicting_2010, title = {Predicting the distributions of marine organisms at the global scale}, volume = {221}, issn = {03043800}, url = {http://linkinghub.elsevier.com/retrieve/pii/S030438000900711X}, journaltitle = {Ecological Modelling}, author = {Ready, Jonathan and Kaschner, Kristin and South, Andy B. and Eastwood, Paul D. and Rees, Tony and Rius, Josephine and Agbayani, Eli and Kullander, Sven and Froese, Rainer}, file = {Ready_etal2010.pdf:/Users/ohara/Library/Application Support/Zotero/Profiles/th8m611h.default/zotero/storage/297AD2JJ/Ready_etal2010.pdf:application/pdf} } Calling the bibliography in R Markdown In your R Markdown document, you call the bibliography file in the YAML header like so: --- output: html_document: toc: true number_sections: true bibliography: ohi.bib csl: ecology-letters.csl --- Notes: You can easily include the bibliography file in a subfolder: bibliography: refs/ohi.bib (if you like to keep your repository folders organized) the csl: allows you to include different “citation style language” formats for different journals; here is a link to Zotero’s style library. I found a github repo with many .csl files too, but they didn’t seem to work - something missing or corrupted. The Zotero ones seemed to work fine. I just put the .csl into the same subfolder as the .bib, so my YAML header looked like: bibliography: refs/ohi.bib csl: refs/ecology-letters.csl Citing in the text of your R markdown In the R Markdown document, the citations look like this: [@articleidentifier] where “articleidentifier” is the author/title fragment/year in the reference listed in the .bib file. So for the reference to Ready et al. 2010 from the .bib above, the citation would look like: [@ready_predicting_2010]. Multiple citations are separated by semicolons within the same set of square brackets: [@ready_predicting_2010; @selig_assessing_2013] For in-line citations where you’ve already mentioned the author’s name and want to exclude it, e.g. Halpern et al (2012) are awesomesauce”, just put a ‘-’ sign in front of the @ sign: “Halpern et al [-@halpern_index_2012] are awesomesauce” You can also put in other text inside the square brackets: [To experience more awesomeness, see also @halpern_spatial_2015] NOTE: One challenge I ran into is figuring out the articleidentifier (aka bibtexkey): This key doesn’t seem to be displayed anywhere in Zotero’s gui, instead you have to search through the .bib document in a text editor. For me, a better option has been to use JabRef, which allows you to search the .bib document more easily: Knitting it all together The knitr package will turn those citation calls into the proper format for the particular journal (e.g. superscripts or parentheses, name or initials or just year, etc) based on the specifications in the .csl. Call a different .csl when submitting to a different journal to change the citation format. The bibliography will be attached at the very end of the document; no need to do anything special at all. But: you probably want to include a heading title - that is not automatic. So for example, the last line of the .Rmd should be # References or the like. The references will be in order according to the citation format, e.g. alphabetical by author, or in order of appearance in the body of the text, with an ID number or without, and formatted to the idiosyncrasies of the given journal. If you use knit child options to attach separate .Rmd files, it still seems to work fine - only the parent gets the header, and as it knits each child .Rmd it annotates the citations and includes them in the final bibliography. Other notes If you have blank items in your Zotero library/collection, those will show up in the .bib file as empty records, but will crash the knitting. So don’t do it. You can edit the .bib manually if you like (e.g. delete empty records that are crashing everything) but if you re-export the library you’ll overwrite your changes, so probably best to get your Zotero set up properly. 5.3.2 Working with Zotero Getting started with zotero (OHIprep_v2019) 5.3.2.1 Zotero group library We have a group OHI Zotero library. This is handy because we can save and organize our OHI references so they are available to everyone (including screenshots, pdfs, and notes). In regard to writing, Zotero offers a very intuitive method of inserting citations into Word documents and (oharac?) describes how to use Zotero with markdown. To use the Zotero group library for OHI, you will first need to be invited to the group. You will then need to download the standalone Zotero program and the web-browser plugin from here. Hopefully everything will sync up automatically. If it works, you should see this: 5.4 Methods document Every year we update a document describing the methods used to calculate the assessment (example methods document: https://raw.githack.com/OHI-Science/ohi-global/published/global_supplement/Supplement.htmlhttps://raw.githack.com/OHI-Science/ohi-global/published/global_supplement/Supplement.html). This file can be accessed from our OHI-science global webpage. The files used to create this document are located here: https://github.com/OHI-Science/ohi-global/tree/draft/global_supplement To maximize flexibility, we have broken our methods into component parts that can be used in multiple contexts. For example, the Rmd files that describe each data layer are incorporated into the official methods document and are also used to create a webpage describing the data layers. Previously, if we updated our methods we had to update both the methods document and the website, but with this approach we only have to make the change in one location. This helps keep our messaging more consistent. Table: A description of the files in the ohi-global/global_supplement repository folder/file name description updates Supplement.Rmd combines all components to create the final methods document No changes to this script are likely necessary, but this Rmd must be knitted when any components change (see description below) CombineLayers.R Combines all the layer Rmds located in the layers_info folder into a single Rmd file called layers_all.Rmd No changes to this script are likely necessary, but this R file must be run whenever there are changes to any of the data layer Rmds layers_all.Rmd Created by CombineLayers.R, includes a description of all data layers Created automatically when CombineLayers.R is run OHI.bib A .bib file of the OHI references (more on that below) Updated yearly BIBcorrect.R Corrects weirdness in the .bib file This probably will need to be updated yearly; this will be determined after reviewing the formatted citation list tables folder with datatables of 10 goal and 8 subgoals No changes likely necessary index_scores.Rmd description of OHI model for calculating index scores No changes likely necessary goal_model.Rmd description of OHI model for calculating goal scores No changes likely necessary trend.Rmd description of OHI model for calculating trend scores No changes likely necessary pressure.Rmd description of OHI model for calculating pressure scores No changes likely necessary resilience. Rmd description of OHI model for calculating resilience scores No changes likely necessary goal_descriptions folder individual Rmd files describing each goal/subgoal Minimal changes to some files may be necessary if the model or data used in a goal changes goal_descriptions_short folder individual Rmd files with a short description of each goal/subgoal Minimal changes to some files may be necessary if the model or data used in a goal changes layers_info folder individual Rmd files with descriptions of each data layer, filenames must match layer names in metadata_documentation datatables Changes to some layers will probably be necessary, but most layers will require no changes figures folder figures displayed in the Supplement.html No changes likely necessary methods-in-ecology-and-evolution.csl instructions for displaying references no need to change unless a different way of displaying references is desired 5.4.1 Steps to updating methods document The methods document is created by knitting ohi-global/global_supplement/Supplement.Rmd. However, many preparations need to be made prior to knitting. 5.4.1.1 Step 1: Update metadata_documentation The data tables in ohi-global/metadata_documentation are used to create the methods document, and consequently must be fully up-to-date and accurate! This includes: layers_eez_base.csv, layers_eez_data_sources.csv, layers_eez_methods.csv, and layers_eez_targets.csv. Currently, the layers_eez_gapfill.csv is not used to create the methods document, but it is still a good idea to update this as well. layers_eez_base.csv This file includes the directory and file name for each of the updated layers. Updates to this file should be completed when you are updating each layer to global (see Chapter 4, Updating Scores). layers_eez_data_sources.csv In the OHI group Zotero library (invite required), you will create a new reference for each of the data sources that have been updated for the current assessment year. NOTE: For the OHI global assessment, you should do all Zotero work in the “OHI Global Refs” folder. This can be done easily by downloading Zotero to your computer and installing the extension in your browser to save the data source directly to the library, where the information can then be edited. (See section 5.3: Citation Management for more information). Create citations in Zotero and update the information, including title, author, abstract, date, URL, and accessed date. “Date” should indicate the year listed in the data citation, OR the most recent year in the dataset if no citation exists. “Accessed” should align with the date indicated in the data prep .Rmd file, OR the timestamp on the saved raw data files if a download date is not obvious. If there are new data sources, fill out the information and add them to “OHI Global Refs” folder. If the datasource has an additional year of data, find that datasource in “OHI Global Refs” and update the date and any other relevant information. Example of completed citation information in Zotero: One you have completed filling in citation information, right click the item in Zotero and choose “Export Item….” Export as a BibLaTeX file and save as a .bib to your computer. It is important that when you right click the item and export it, you are working from the “OHI Global Refs” folder. Open this file in a text editing app and copy the tag at the beginning: Paste this tag into layers_eez_data_sources.csv in the ds_reference column. If it is an update to an existing data source, copy over it and update the ds_years column for the time range of the data (also found in the Rmd, or within the data source itself). Check to make sure the other information is still accurate, and add a new column “ds_updated_20??” to indicate which references have been updated. Fill in “y” if you are updating an existing data source. If it is a new data source, paste the tag into a new line and fill in the other information (name, description, years, and native resolution). For all references that were not updated, fill in the ds_updated_20?? with “n” or “NA.” layers_eez_dataprep dataprep_url: File path to the knitted html file . Note: finalized data prep files should all be knitted BEFORE attempting to update this document, as this can take some time! layers_eez_reference reference: Alias tag created BibLaTeX file as described above. This tag should match exactly with the tag in layers_eez_data_sources.csv. Always double check this! layers_eez_updates updates: Short description of updates to the data; usually is additional year of data and/or changes to gapfilling methods or other calculations. layers_eez_gapfill.csv Add file path location of gapfilling report for each layer. layers_eez_targets.csv This really only needs to be updated when layers are removed/added. 5.4.1.2 Step 2: Update OHI.bib Make sure all references are included in the OHI Zotero library (see Section 5.3: Citation Management for more). Then export the folder “OHI Global Refs” as a BibLaTeX file and replace the OHI.bib file in ohi-global/global_supplement with the updated file. We have noticed that some of the OHI.bib entries need to be modified to report correctly. For example, when the author of a report is an agency, such as the US State Depart, it will be reported as “Depart, US.” For this reason, we use the BIBcorrect.R file to correct and then overwrite the OHI.bib file. 5.4.1.3 Step 3: Update layers_info The layers_info folder includes an Rmd file for every data layer used to calculate the global OHI assessment. The files describe the general methods and data used to generate the layer. Ideally, these Rmd files do not include information that changes each year (e.g., final year of data used in analysis, links to data preparation files on Github, etc), so they can be used each year with minimal changes. Components that change every year should be included in tables, such as those in _ohi-global/metadata_documentation. However, if there have been changes to the model or data used to generate a layer it will be necessary to update the corresponding Rmd file. After the Rmds have been updated it is necesary to run the CombineLayers.R file, which merges all the layer information into a single document, layers_all.Rmd. 5.4.1.4 Step 4: Review other files Review whether any of the other files require editing. There may be changes to the text to make it clearer, but otherwise, the following files are unlikely to change: There will be no changes to the following files: goal_model.Rmd, insex_scores.Rmd, pressure.Rmd, resilience.Rmd, or trend.Rmd, unless changes are made to the OHI models (which is unlikely). The Rmds describing the goal models in the goal_descriptions and goal_descriptions_short folders will only change if there have been changes to the goal model or data. Changes to the goal/subgoal descriptions in the “tables” folder are unlikely. 5.4.1.5 Step 5: Knit Supplement.Rmd Review the Supplement.Rmd document to update the assessment year (i.e., title at top, assessmentYear variable in this code chunk, update figure 3.1). Knit the file and review the html output. Make any necessary changes and repeat…seemingly endlessly until everything is correct. 5.5 Results document After producing the final scores, we create a document that describes the results of the assessment: https://raw.githack.com/OHI-Science/ohi-global/published/global2018/Results/Supplement_Results.html. This file can be accessed from our OHI-science global webpage. The file is created using this Rmd: ohi-global/yearly_results/global20??/Results/Supplement_Results.Rmd. It is critical to carefully step through this script and modify as needed; for example, the date of the radicalFile object must match the date appended to the csv file of scores created by Results_first_look.rmd (e.g., radicalFile = ‘2018-10-10,’ ~line 92). And, of course, freely modify this script to reflect the data/figures you believe will be most useful to people. This could involve editing text, removing particular figures, adding figures, etc. NOTE: If there are any changes to the scores, it is important to run the Results_first_look.Rmd file prior to running this script. Many of the figures in the Supplement_Results document are actually generated by the Results_first_look.Rmd script. 5.6 Update ESRI Living Atlas of the World OHI map Every year we update our OHI ARCGIS online map to reflect the current assessment year’s scores. You can find the map here: ARCGIS Living Atlas of the World by searching for “Ocean Health Index.” Through UCSB, you should have an ARCGIS online account. You will need to be added to the group “Global Ocean Health Index” by either Gage Clawson or Melanie Frazier (or whoever is running OHI at this point). https://ucsb.maps.arcgis.com/home/group.html?id=e2857950e3314d77a1fd14959f3cce8e#overview First, you will run the script in the ohi-global repo, located in ohi-global/yearly_results/globalxxxx/ESRI_data/prepping_esri_data.Rmd. Link to 2021 prep. Once you have run that script, you will need to upload the created data into the ARCGIS OHI global map. To obtain the zip file which you will upload, export the .dbf, .shp, .shx, and .prj files from the ohi-global/yearly_results/globalxxxx/ESRI_data/scores_xxxx folder on Mazu, and rename to “ohi_scores_2020_final.zip.” NOTE: It is important that this file is named “ohi_scores_2020_final.zip,” even if the assessment year is not 2020. This is because we originally uploaded the data and created an ARCGIS map from it when it was named “ohi_scores_2020_final.zip.” I’m sure we could figure out how to change the name of the source file on ARCGIS online if we wanted to, or recreate the map with a non-year specific name, but at this time its not worth the effort… just roll with 2020 in the name. Now log into https://ucsb.maps.arcgis.com/. You should’ve been added to the “Global Ocean Health Index” group by now. Click on Groups —&gt; Global Ocean Health Index —&gt; and update the files accordingly as instructed below. Upload the ohi_scores_2020_final.zip file to “OHI Scores Source” by clicking “Update Data” —&gt; “Overwrite Entire Layer.” Now the data is updated on ARCGIS Online! All you have left to do is edit the text on “OHI Scores Source” and “Historical Global Ocean Health Index Scores (2012-2021)” to match the current assessment year, and all of the new data should be reflected in the ARCGIS Living Atlas of the World map for OHI. 5.7 Updates document 5.8 Upload to a repository One of the final steps of an assessment is submitting the final data (and related files) to a data repository. This makes the files publicly available and provides a DOI (digital object identifier, https://www.doi.org/) used to officially cite the data. We have been using the Knowledge Network for Biocomplexity, or KNB (https://knb.ecoinformatics.org/) as our data repository. An example of our data on KNB is here: https://knb.ecoinformatics.org/view/doi:10.5063/F12Z13R6 Signing into KNB requires an ORCID account. An ORCID account is obtained here: https://orcid.org/register. You will then make your way to https://knb.ecoinformatics.org/. Select the SIGN IN tab, and then “Sign in with ORCID”: Select the “Upload data,” and start adding files and information: The following is the information we used for the 2018 assessment, but please modify and improve as desired! 5.8.0.1 Overview Title: Global Ocean Health Index 2018 assessment Abstract: Scores from the 2018 global Ocean Health Index (OHI) assessment and accompanying data and models. The global Ocean Health Index assesses ocean health for 220 coastal countries and territories and has been conducted yearly since 2012. The Index describes how well we are sustainably managing 10 goals which represent the full suite of benefits that people want and need from the ocean. These goals include: artisanal fishing opportunity, biodiversity, carbon storage, clean waters, coastal livelihoods and economies, coastal protection, food provision, natural products, sense of place, and tourism and recreation. Each goal is given a score ranging from 0 to 100, and the full suite of goal scores are then averaged to obtain an overall index score for each region. Please see http://ohi-science.org/ for additional resources and information. Keywords: OHI, index, ocean 5.8.0.2 People OHI team (including the OHI Fellows) Contacts: If in doubt, put Benjamin Halpern 5.8.0.3 Dates First data is 2012. The later date is the year of the assessment. 5.8.0.4 Locations Short geographic description: Global country and territorial EEZ regions (N=220) Northwest coordinates: 90 -180 Southeast coordinates: -90 180 5.8.0.5 Taxa NA 5.8.0.6 Methods Step 1: See Methods.html file 5.8.0.7 Add Files Please use your judgment, but we included the following files in the global 2018 assessment: scores.csv: scores file that is created secondarily to include region names and expanded goal names. Methods.html: methods used to calculate the global OHI scores (this is created in the global_supplement folder in the ohi-global repository). Global_OHI_Results: Figures and tables of global results. This is currently an informal document, but I would like to improve this in future years. Zip files of the 3 repositories used to calculate the global OHI assessment: ohiprep, ohi-global, and ohicore. These files are downloaded from the “release” version of repository (this assumes you have already created the release). You navigate to the release by first going to the repository of interest and selecting “releases”: Then download the .zip option: Once all the information has been entered and the files uploaded to the KNB site you can obtain a link for your data. Navigate to “My data sets” and select the one you are working on from the list and copy the web address. Create an issue and provide the link so anyone who wants to review the information can do so. You can easily edit everything at this point! NOTE: At this point the data does not have an official DOI. Once everyone is satisfied with the content, you can officially “Publish with DOI”: The data now officially has a DOI, and you can mark this off your list of things to do! "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
